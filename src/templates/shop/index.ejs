<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Dice Shop - Mixed Faces & Modified “Click Me” Behavior</title>

  <style>
    /* Full-screen felt background or a solid color */
    html, body {
      margin: 0; 
      padding: 0; 
      height: 100%;
      background: url("/assets/images/felt_image.jpg") no-repeat center center fixed;
      background-size: cover;
    }

    /* Container holds canvas + absolutely positioned buttons */
    #diceContainer {
      position: relative;
      width: 80%;
      max-width: 1200px;
      height: 70vh;  
      margin: 60px auto;
      /* border: 1px solid #999;  */
      background: transparent; 
    }
    #diceCanvas {
      width: 100%; 
      height: 100%; 
      display: block;
      background: transparent;
    }

    /* Shared button styles */
    .dice-button {
      position: absolute;
      display: none;
      background: #000;
      color: #fff;
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      font-family: Roboto;
      font-size: 14px;
      text-align: center;
      cursor: pointer;
    }
  </style>
</head>
<body>

  <section id="diceContainer">
    <canvas id="diceCanvas"></canvas>

    <!-- Four "Add to Cart" buttons, one per die -->
    <button id="addToCartButton1" class="dice-button">Add to Cart</button>
    <button id="addToCartButton2" class="dice-button">Add to Cart</button>
    <button id="addToCartButton3" class="dice-button">Add to Cart</button>
    <button id="addToCartButton4" class="dice-button">Add to Cart</button>

    <!-- One special "Click Me" button just for Die #1 -->
    <button id="clickMeButton1" class="dice-button">Click Me</button>
  </section>

  <!-- Three.js and GSAP from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

  <script>
  /************************************************************
   * Global Setup & Variables
   ************************************************************/
  let autoRotationActive = false;
  let autoRotationInterval = null; 
  let hoveredDie = null;   // Which die is currently hovered

  const container = document.getElementById('diceContainer');
  const canvas = document.getElementById('diceCanvas');
  const scene = new THREE.Scene();

  const camera = new THREE.PerspectiveCamera(
    45,
    container.clientWidth / container.clientHeight,
    0.1,
    1000
  );
  camera.position.set(0, 0, 36);

  const renderer = new THREE.WebGLRenderer({
    canvas: canvas,
    antialias: true,
    alpha: true
  });
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.setPixelRatio(window.devicePixelRatio);

  function onWindowResize() {
    const w = container.clientWidth;
    const h = container.clientHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
  }
  window.addEventListener('resize', onWindowResize);
  onWindowResize();

  // Lighting
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambientLight);
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(0, 1, 1);
  scene.add(directionalLight);

  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  /************************************************************
   * 1) createDiceWithImages => 6 faces, no transparency
   ************************************************************/
  function createDiceWithImages(faceUrls, size = 10) {
    const loader = new THREE.TextureLoader();
    const materials = faceUrls.map(url => {
      return new THREE.MeshPhongMaterial({ 
        map: loader.load(url),
        transparent: false,
        side: THREE.FrontSide
      });
    });

    const geometry = new THREE.BoxGeometry(size, size, size);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();

    const dice = new THREE.Mesh(geometry, materials);

    // Optional edges
    const edges = new THREE.EdgesGeometry(geometry);
    const lineMat = new THREE.LineBasicMaterial({ color: 0x000000 });
    const edgeLines = new THREE.LineSegments(edges, lineMat);
    dice.add(edgeLines);

    return dice;
  }

  /************************************************************
   * 2) getFrontFaceIndex(rotY)
   ************************************************************/
  function getFrontFaceIndex(rotY) {
    let quarterTurns = Math.round(rotY / (Math.PI / 2)) % 4;
    if (quarterTurns < 0) quarterTurns += 4;
    // faceCycle = [4=+Z, 0=+X, 5=-Z, 1=-X]
    const faceCycle = [4, 0, 5, 1];
    return faceCycle[quarterTurns];
  }

  /************************************************************
   * 3) Face Arrays for Each Die
   *    Mix up the numeric faces so they differ
   *    but keep +Z = product
   ************************************************************/

  // Die #1 (same as your original example: +X=3, -X=4, +Y=1, -Y=6, +Z=product-1, -Z=5)
  const dice1FaceUrls = [
    '/assets/images/dice/dice-three.png',  // +X
    '/assets/images/dice/dice-four.png',   // -X
    '/assets/images/dice/dice-one.png',    // +Y
    '/assets/images/dice/dice-six.png',    // -Y
    '/assets/images/dice/dice-product-1.png', // +Z
    '/assets/images/dice/dice-five.png'    // -Z
  ];

  // Die #2 => +X=2, -X=5, +Y=1, -Y=6, +Z=product-2, -Z=4
  const dice2FaceUrls = [
    '/assets/images/dice/dice-two.png',   // +X
    '/assets/images/dice/dice-five.png',  // -X
    '/assets/images/dice/dice-one.png',   // +Y
    '/assets/images/dice/dice-six.png',   // -Y
    '/assets/images/dice/dice-product-2.png', // +Z
    '/assets/images/dice/dice-four.png'   // -Z
  ];

  // Die #3 => +X=4, -X=3, +Y=2, -Y=5, +Z=product-3, -Z=1
  const dice3FaceUrls = [
    '/assets/images/dice/dice-four.png', // +X
    '/assets/images/dice/dice-three.png',// -X
    '/assets/images/dice/dice-two.png',  // +Y
    '/assets/images/dice/dice-five.png', // -Y
    '/assets/images/dice/dice-product-3.png', // +Z
    '/assets/images/dice/dice-one.png'   // -Z
  ];

  // Die #4 => +X=6, -X=1, +Y=3, -Y=4, +Z=product-4, -Z=2
  const dice4FaceUrls = [
    '/assets/images/dice/dice-six.png',   // +X
    '/assets/images/dice/dice-one.png',   // -X
    '/assets/images/dice/dice-three.png', // +Y
    '/assets/images/dice/dice-four.png',  // -Y
    '/assets/images/dice/dice-product-4.png', // +Z
    '/assets/images/dice/dice-two.png'    // -Z
  ];

  /************************************************************
   * 4) createDiceData => store anchors
   *    Move "Click Me" anchor even higher => (0,5,5)
   ************************************************************/
  function createDiceData(faceUrls, buttonId, clickMeButtonId=null) {
    const dice = createDiceWithImages(faceUrls, 10);

    // Product anchor near bottom
    const productAnchor = new THREE.Vector3(0, -4, 5);
    // Move the "Click Me" anchor further up => (0,5,5)
    const clickMeAnchor = new THREE.Vector3(0, 3.5, 5);

    dice.userData = {
      productFace: 4,  // +Z
      productAnchor: productAnchor,
      buttonId: buttonId,
      
      clickMeFace: 4,
      clickMeAnchor: clickMeAnchor,
      clickMeButtonId: clickMeButtonId,
      clickMeUsed: false,

      rotationTween: null,
      targetRotation: 0
    };
    return dice;
  }

  // Die #1 => Has the "Click Me"
  const dice1 = createDiceData(dice1FaceUrls, "addToCartButton1", "clickMeButton1");
  dice1.position.set(-7, 7, 0);
  scene.add(dice1);

  const dice2 = createDiceData(dice2FaceUrls, "addToCartButton2");
  dice2.position.set(7, 7, 0);
  scene.add(dice2);

  const dice3 = createDiceData(dice3FaceUrls, "addToCartButton3");
  dice3.position.set(-7, -7, 0);
  scene.add(dice3);

  const dice4 = createDiceData(dice4FaceUrls, "addToCartButton4");
  dice4.position.set(7, -7, 0);
  scene.add(dice4);

  const diceArray = [dice1, dice2, dice3, dice4];

  /************************************************************
   * 5) Give dice2, dice3, dice4 initial rotations
   *    so they do NOT start on product side
   ************************************************************/
  // e.g. dice2 => 90° (front => +X),
  //      dice3 => 180° (front => -Z),
  //      dice4 => -90° (front => -X).
  dice2.rotation.y =  Math.PI / 2; 
  dice3.rotation.y =  Math.PI;     
  dice4.rotation.y = -Math.PI / 2;

  /************************************************************
   * 6) Hover detection
   ************************************************************/
  function checkHover(event) {
    const rect = canvas.getBoundingClientRect();
    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(diceArray);

    hoveredDie = (intersects.length > 0) ? intersects[0].object : null;
  }
  canvas.addEventListener('mousemove', checkHover);

  /************************************************************
   * 7) rotateDice(die, quarterTurns=1)
   ************************************************************/
  function rotateDice(die, quarterTurns = 1) {
    if (die.userData.targetRotation === undefined) {
      die.userData.targetRotation = die.rotation.y;
    }
    const angleIncrement = quarterTurns * (Math.PI / 2);
    die.userData.targetRotation += angleIncrement;

    if (die.userData.rotationTween) {
      die.userData.rotationTween.kill();
    }

    const remaining = die.userData.targetRotation - die.rotation.y;
    const duration = Math.abs(remaining) / (Math.PI / 2);

    die.userData.rotationTween = gsap.to(die.rotation, {
      duration: duration,
      y: die.userData.targetRotation,
      ease: "power2.out",
      onUpdate: () => {
        updateButtonsPosition(die);
      },
      onComplete: () => {
        updateButtonsPosition(die);
        die.userData.rotationTween = null;
      }
    });
  }

  /************************************************************
   * 8) canvas.addEventListener('click')
   *    => if user clicks a die, rotate it, 
   *       if it's die1 => hide "Click Me", start auto-rotation
   ************************************************************/
  canvas.addEventListener('click', (event) => {
    checkHover(event);
    if (!hoveredDie) return;

    // If user clicked die1, permanently hide "Click Me"
    if (hoveredDie === dice1 && !dice1.userData.clickMeUsed) {
      dice1.userData.clickMeUsed = true;
    }

    // Rotate the hovered die
    rotateDice(hoveredDie, 1);

    // If auto-rotation not active, start it
    if (!autoRotationActive) {
      autoRotationActive = true;
      startAutoRotation();
    }
  });

  /************************************************************
   * 9) updateButtonsPosition(die)
   ************************************************************/
  function updateButtonsPosition(die) {
    const frontFaceIndex = getFrontFaceIndex(die.rotation.y);

    // Add to Cart?
    const productBtn = document.getElementById(die.userData.buttonId);
    if (productBtn) {
      if (frontFaceIndex === die.userData.productFace) {
        productBtn.style.display = 'block';
        projectAnchor(die, die.userData.productAnchor, productBtn, -10);
      } else {
        productBtn.style.display = 'none';
      }
    }

    // "Click Me" on die1
    if (die.userData.clickMeButtonId) {
      const clickBtn = document.getElementById(die.userData.clickMeButtonId);
      if (!clickBtn) return;

      // If we've hidden it, don't show again
      if (die.userData.clickMeUsed) {
        clickBtn.style.display = 'none';
        return;
      }

      if (frontFaceIndex === die.userData.clickMeFace) {
        clickBtn.style.display = 'block';
        // anchor is (0,5,5) => even higher
        projectAnchor(die, die.userData.clickMeAnchor, clickBtn, 0);
      } else {
        clickBtn.style.display = 'none';
      }
    }
  }

  /************************************************************
   * 10) projectAnchor(die, localAnchor, button, extraOffsetY=0)
   ************************************************************/
  function projectAnchor(die, localAnchor, button, extraOffsetY=0) {
    const worldPos = die.localToWorld(localAnchor.clone());
    const screenPos = worldPos.clone();
    screenPos.project(camera);

    const w = container.clientWidth;
    const h = container.clientHeight;
    const x = (screenPos.x + 1) / 2 * w;
    const y = (-screenPos.y + 1) / 2 * h;

    const rect = button.getBoundingClientRect();
    const bw = rect.width;
    const bh = rect.height;

    button.style.left = (x - bw/2) + 'px';
    button.style.top  = (y - bh/2 + extraOffsetY) + 'px';
  }

  /************************************************************
   * 11) startAutoRotation => every 7 seconds
   ************************************************************/
  function startAutoRotation() {
    autoRotationInterval = setInterval(() => {
      // pick a random die
      const randomIndex = Math.floor(Math.random() * diceArray.length);
      const chosenDie = diceArray[randomIndex];

      // skip if hovered
      if (chosenDie === hoveredDie) {
        console.log("Skipped auto-rotate because chosen die is hovered.");
        return;
      }

      // random quarter-turns: 1..3
      const randomQuarterTurns = Math.floor(Math.random() * 3) + 1;
      rotateDice(chosenDie, randomQuarterTurns);
    }, 7000);
  }

  /************************************************************
   * 12) Button Listeners
   *     - Add to Cart
   *     - "Click Me" => revolve dice1, hide button, start auto-rotation
   ************************************************************/
  // Add to Cart
  ["addToCartButton1","addToCartButton2","addToCartButton3","addToCartButton4"].forEach(id => {
    const b = document.getElementById(id);
    b.addEventListener('click', (evt) => {
      evt.stopPropagation();
      // No immediate logic here
    });
  });

  // "Click Me" on Die #1 specifically
  const clickMeBtn = document.getElementById("clickMeButton1");
  clickMeBtn.addEventListener("click", (evt) => {
    evt.stopPropagation();

    // Hide "Click Me"
    dice1.userData.clickMeUsed = true;

    // Rotate dice1 by 90°
    rotateDice(dice1, 1);

    // Start auto-rotation if not active
    if (!autoRotationActive) {
      autoRotationActive = true;
      startAutoRotation();
    }
  });

  /************************************************************
   * 13) Animation + Initial Button Updates
   ************************************************************/
  function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  }
  animate();

  // Do an initial button update, so the new rotations reflect right away
  diceArray.forEach(die => {
    updateButtonsPosition(die);
  });
  </script>

</body>
</html>
