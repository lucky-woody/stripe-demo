<!-- src/templates/shop/index.ejs -->
<section id="diceContainer">
  <canvas id="diceCanvas" style="width: 100%; height: 100%; display: block;"></canvas>
  <div id="addToCartButton" style="display: none; position: absolute; background-color: rgba(255,255,255,0.9); padding: 10px; border: 1px solid #D06F6F; cursor: pointer;">
    Add to Cart
  </div>
</section>

<!-- Include Three.js and GSAP from CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

<script>
  // ----------------------------------------------------------------------
  // (Optional) Test with a standard BoxGeometry first
  //    If using RoundedBoxGeometry is causing strange artifacts,
  //    comment out the RoundedBox lines and uncomment the BoxGeometry lines.
  // ----------------------------------------------------------------------
  
  // --- RoundedBoxGeometry Definition ---
  if (!THREE.RoundedBoxGeometry) {
    THREE.RoundedBoxGeometry = function(width, height, depth, radius, smoothness) {
      // Minimal "rounded box" hack using ExtrudeGeometry
      const shape = new THREE.Shape();
      const eps = 0.00001;
      const radius0 = radius - eps;
      // Start at bottom left
      shape.moveTo(eps, radius0);
      shape.absarc(radius0, radius0, radius0, -Math.PI, -Math.PI/2, false);
      shape.absarc(radius0, height - radius*2 + radius0, radius0, -Math.PI/2, 0, false);
      shape.absarc(width - radius*2 + radius0, height - radius*2 + radius0, radius0, 0, Math.PI/2, false);
      shape.absarc(width - radius*2 + radius0, radius0, radius0, Math.PI/2, Math.PI, false);
      shape.lineTo(eps, radius0);
      
      const extrudeSettings = {
        depth: depth - radius*2,
        bevelEnabled: true,
        bevelThickness: radius,
        bevelSize: radius,
        bevelSegments: smoothness * 2,
        steps: 1,
      };
      const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      geometry.center();
      
      // Force recompute normals, sometimes helps if geometry appears "inside out"
      geometry.computeFaceNormals();
      geometry.computeVertexNormals();
      return geometry;
    };
  }
  
  // ----------------------------------------------------------------------
  // Scene Setup
  // ----------------------------------------------------------------------
  console.log("Creating scene...");
  const scene = new THREE.Scene();
  // scene.background = new THREE.Color(0xC5A6E0);
  
  const container = document.getElementById("diceContainer");
  const canvas = document.getElementById("diceCanvas");
  
  const camera = new THREE.PerspectiveCamera(
    45,
    container.clientWidth / container.clientHeight,
    0.1,
    1000
  );
  camera.position.set(0, 0, 36);
  
  // const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
  const renderer = new THREE.WebGLRenderer({
  canvas: document.getElementById('diceCanvas'),
  antialias: true,
  alpha: true  // <-- Important for transparency
});

  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  
  function onWindowResize() {
    const width = container.clientWidth;
    const height = container.clientHeight;
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    renderer.setSize(width, height);
  }
  window.addEventListener('resize', onWindowResize);
  onWindowResize();
  
  console.log("Scene, camera, and renderer set up.");
  
  // ----------------------------------------------------------------------
  // Lighting
  // ----------------------------------------------------------------------
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambientLight);
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(0, 1, 1);
  scene.add(directionalLight);
  console.log("Lights added to scene.");
  
  // ----------------------------------------------------------------------
  // Dice Creation with Images
  // ----------------------------------------------------------------------
  function createDiceWithImages(faceUrls, diceSize = 10, diceLabel = "Dice") {
    // Expect exactly 6 image URLs for the 6 faces of a box
    if (faceUrls.length !== 6) {
      console.warn("createDiceWithImages requires exactly 6 image URLs. Received:", faceUrls);
    }
  
    // Use THREE.TextureLoader and add logging
    const loader = new THREE.TextureLoader();
    
    // We'll store an array of materials, each with a loaded texture
    const materials = faceUrls.map(url => {
      const texture = loader.load(
        url,
        () => console.log(`[${diceLabel}] Texture loaded OK from: ${url}`),
        undefined,
        err => console.error(`[${diceLabel}] Error loading texture from: ${url}`, err)
      );
      
      // If you suspect backface or side issues, you can try 'doubleSide'
      // or just leave it as default 'frontSide'.
      return new THREE.MeshPhongMaterial({
        map: texture,
        // side: THREE.DoubleSide, // optionally test double-sided
      });
    });
    
    // ----------------------------------------------------------------------
    // Switch geometry if you suspect the extrude is messing up
    // ----------------------------------------------------------------------
    // ROUNDED BOX:
    // const geometry = new THREE.RoundedBoxGeometry(diceSize, diceSize, diceSize, 0.1, 4);
  
    // REGULAR BOX (comment out the above line if you want to test a standard box)
    const geometry = new THREE.BoxGeometry(diceSize, diceSize, diceSize);
    
    // Recompute normals just in case
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();
    
    const dice = new THREE.Mesh(geometry, materials);
  
    // Optional: add black edges
    const edges = new THREE.EdgesGeometry(geometry);
    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
    const edgeLines = new THREE.LineSegments(edges, lineMaterial);
    dice.add(edgeLines);
  
    console.log(`[${diceLabel}] Dice created with face URLs:`, faceUrls);
    return dice;
  }
  
  // ----------------------------------------------------------------------
  // Define 4 DICE with 6 images each
  // ----------------------------------------------------------------------
  const dice1FaceUrls = [
    '/assets/images/dice/dice-one.png',
    '/assets/images/dice/dice-two.png',
    '/assets/images/dice/dice-three.png',
    '/assets/images/dice/dice-four.png',
    '/assets/images/dice/dice-five.png',
    '/assets/images/dice/dice-six.png'
  ];
  const dice1 = createDiceWithImages(dice1FaceUrls, 10, "Dice1");
  dice1.userData.product = "Dice 1 Product";
  
  
  const dice2FaceUrls = [
    '/assets/images/dice/dice-one.png',
    '/assets/images/dice/dice-two.png',
    '/assets/images/dice/dice-three.png',
    '/assets/images/dice/dice-four.png',
    '/assets/images/dice/dice-five.png',
    '/assets/images/dice/dice-six.png'
  ];

  
  const dice2 = createDiceWithImages(dice2FaceUrls, 10, "Dice2");
  dice2.userData.product = "Dice 2 Product";
  
  const dice3FaceUrls = [
    '/assets/images/dice/dice-one.png',
    '/assets/images/dice/dice-two.png',
    '/assets/images/dice/dice-three.png',
    '/assets/images/dice/dice-four.png',
    '/assets/images/dice/dice-five.png',
    '/assets/images/dice/dice-six.png'
  ]; // fill in actual paths
  const dice3 = createDiceWithImages(dice3FaceUrls, 10, "Dice3");
  dice3.userData.product = "Dice 3 Product";
  
  const dice4FaceUrls = [
    '/assets/images/dice/dice-one.png',
    '/assets/images/dice/dice-two.png',
    '/assets/images/dice/dice-three.png',
    '/assets/images/dice/dice-four.png',
    '/assets/images/dice/dice-five.png',
    '/assets/images/dice/dice-six.png'
  ]; // fill in actual paths
  const dice4 = createDiceWithImages(dice4FaceUrls, 10, "Dice4");
  dice4.userData.product = "Dice 4 Product";
  
  // Position them
  dice1.position.set(-7, 7, 0);
  dice2.position.set(7, 7, 0);
  dice3.position.set(-7, -7, 0);
  dice4.position.set(7, -7, 0);
  
  scene.add(dice1, dice2, dice3, dice4);
  console.log("All dice added to scene.");
  
  const diceArray = [dice1, dice2, dice3, dice4];
  
  // ----------------------------------------------------------------------
  // Raycaster + Click => Rotate the dice
  // ----------------------------------------------------------------------
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  
  canvas.addEventListener('click', event => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
  
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(diceArray);
  
    if (intersects.length > 0) {
      const clickedDice = intersects[0].object;
  
      if (clickedDice.userData.targetRotation === undefined) {
        clickedDice.userData.targetRotation = clickedDice.rotation.y;
      }
  
      clickedDice.userData.targetRotation += Math.PI / 2;
  
      if (clickedDice.userData.rotationTween) {
        clickedDice.userData.rotationTween.kill();
      }
  
      const remaining = clickedDice.userData.targetRotation - clickedDice.rotation.y;
      const duration = remaining / (Math.PI / 2);
  
      clickedDice.userData.rotationTween = gsap.to(clickedDice.rotation, {
        duration: duration,
        y: clickedDice.userData.targetRotation,
        ease: "power2.out",
        onUpdate: function() {
          updateAddToCartButtonPosition(clickedDice);
        },
        onComplete: function() {
          updateAddToCartButtonPosition(clickedDice);
          clickedDice.userData.rotationTween = null;
        }
      });
    }
  });
  
  // ----------------------------------------------------------------------
  // Position the "Add to Cart" button on the front face
  // ----------------------------------------------------------------------
  function updateAddToCartButtonPosition(dice) {
    const diceSize = 12;
    const halfSize = diceSize / 2;
    const localPoint = new THREE.Vector3(0, 0, halfSize);
    const worldPoint = dice.localToWorld(localPoint.clone());
    const vector = worldPoint.clone();
    vector.project(camera);
  
    const width = container.clientWidth;
    const height = container.clientHeight;
    const x = (vector.x + 1) / 2 * width;
    const y = (-vector.y + 1) / 2 * height;
  
    const button = document.getElementById('addToCartButton');
    button.style.left = (x - 50) + 'px';
    button.style.top = (y - 20) + 'px';
    button.dataset.product = dice.userData.product;
    button.style.display = 'block';
  }
  
  // ----------------------------------------------------------------------
  // Add to Cart Button Handler
  // ----------------------------------------------------------------------
  document.getElementById('addToCartButton').addEventListener('click', function(event) {
    event.stopPropagation();
    const product = this.dataset.product;
    alert(`Added ${product} to cart!`);
    this.style.display = 'none';
  });
  
  // ----------------------------------------------------------------------
  // Animation Loop
  // ----------------------------------------------------------------------
  function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  }
  animate();
  </script>