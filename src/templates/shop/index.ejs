<!-- src/templates/shop/index.ejs -->
<main id="diceContainer" style="position: relative; height: 80vh; width: 100%; max-width: 1280px; margin: 0 auto;">
  <canvas id="diceCanvas" style="width: 100%; height: 100%; display: block;"></canvas>
  <div id="addToCartButton" style="display: none; position: absolute; background-color: rgba(255,255,255,0.9); padding: 10px; border: 1px solid #D06F6F; cursor: pointer;">
    Add to Cart
  </div>
</main>

<!-- Include Three.js and GSAP from CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

<script>
// --- RoundedBoxGeometry Definition ---
// A minimal implementation to get rounded edges; for a more complete version,
 // consider using the official module from three.js examples.
if (!THREE.RoundedBoxGeometry) {
  THREE.RoundedBoxGeometry = function(width, height, depth, radius, smoothness) {
    // This implementation uses ExtrudeGeometry to simulate a rounded box.
    // Note: This is a simplified version and may not suit all needs.
    const shape = new THREE.Shape();
    const eps = 0.00001;
    const radius0 = radius - eps;
    // Start at bottom left
    shape.moveTo(eps, radius0);
    shape.absarc(radius0, radius0, radius0, -Math.PI, -Math.PI/2, false);
    shape.absarc(radius0, height - radius*2 + radius0, radius0, -Math.PI/2, 0, false);
    shape.absarc(width - radius*2 + radius0, height - radius*2 + radius0, radius0, 0, Math.PI/2, false);
    shape.absarc(width - radius*2 + radius0, radius0, radius0, Math.PI/2, Math.PI, false);
    shape.lineTo(eps, radius0);
    
    const extrudeSettings = {
      depth: depth - radius*2,
      bevelEnabled: true,
      bevelThickness: radius,
      bevelSize: radius,
      bevelSegments: smoothness * 2,
      steps: 1,
    };
    const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
    geometry.center();
    return geometry;
  };
}

// --- Scene Setup ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xC5A6E0);

const container = document.getElementById("diceContainer");
const canvas = document.getElementById("diceCanvas");

const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
camera.position.set(0, 0, 30);

const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
renderer.setSize(container.clientWidth, container.clientHeight);
renderer.setPixelRatio(window.devicePixelRatio);

function onWindowResize() {
  const width = container.clientWidth;
  const height = container.clientHeight;
  camera.aspect = width / height;
  camera.updateProjectionMatrix();
  renderer.setSize(width, height);
}
window.addEventListener('resize', onWindowResize);
onWindowResize();

// --- Lighting ---
const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
directionalLight.position.set(0, 1, 1);
scene.add(directionalLight);

// --- Dice Creation ---
// This function creates a dice with a dynamic canvas texture (white face with a black border and centered product text)
// and uses RoundedBoxGeometry to get smooth, rounded edges.
function createDice(productLabel) {
  // Create a texture using canvas.
  const canvasTex = document.createElement('canvas');
  canvasTex.width = 256;
  canvasTex.height = 256;
  const ctx = canvasTex.getContext('2d');
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, canvasTex.width, canvasTex.height);
  ctx.strokeStyle = '#000000';
  ctx.lineWidth = 8;
  ctx.strokeRect(0, 0, canvasTex.width, canvasTex.height);
  ctx.fillStyle = '#000000';
  ctx.font = '30px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(productLabel, canvasTex.width / 2, canvasTex.height / 2);
  
  const texture = new THREE.CanvasTexture(canvasTex);
  const materials = [];
  for (let i = 0; i < 6; i++) {
    materials.push(new THREE.MeshPhongMaterial({ map: texture }));
  }
  // Increase dice size from 7.5 to 9.
  const diceSize = 9;
  const geometry = new THREE.RoundedBoxGeometry(diceSize, diceSize, diceSize, 0.75, 4);
  const dice = new THREE.Mesh(geometry, materials);
  // Ensure the front face is directly facing the camera.
  dice.rotation.x = 0;
  dice.rotation.y = 0;
  dice.userData = { product: productLabel, targetRotation: 0, rotationTween: null };
  
  // Add black edges for extra clarity.
  const edges = new THREE.EdgesGeometry(geometry);
  const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
  const edgeLines = new THREE.LineSegments(edges, lineMaterial);
  dice.add(edgeLines);
  
  return dice;
}

// Create four dice.
const dice1 = createDice("Product 1");
const dice2 = createDice("Product 2");
const dice3 = createDice("Product 3");
const dice4 = createDice("Product 4");

// Arrange dice in a 2×2 grid; positions have been adjusted to bring them closer together.
// With dice size set to 9, these positions ensure a small gap even when the dice are spinning.
dice1.position.set(-7, 7, 0);
dice2.position.set(7, 7, 0);
dice3.position.set(-7, -7, 0);
dice4.position.set(7, -7, 0);
scene.add(dice1, dice2, dice3, dice4);
const diceArray = [dice1, dice2, dice3, dice4];

// --- Raycaster and Click Control ---  
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

// Instead of blocking clicks during animation, each click adds an extra 90° rotation.
canvas.addEventListener('click', function(event) {
  const rect = canvas.getBoundingClientRect();
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
  
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(diceArray);
  
  if (intersects.length > 0) {
    const clickedDice = intersects[0].object;
    // Initialize targetRotation if not already set.
    if (clickedDice.userData.targetRotation === undefined) {
      clickedDice.userData.targetRotation = clickedDice.rotation.y;
    }
    // Add an additional 90° (Math.PI/2) to the target rotation.
    clickedDice.userData.targetRotation += Math.PI / 2;
    
    // If a tween is already running, kill it so we can update the target.
    if (clickedDice.userData.rotationTween) {
      clickedDice.userData.rotationTween.kill();
    }
    
    // Calculate remaining rotation and set duration (1 second per quarter-turn).
    const remaining = clickedDice.userData.targetRotation - clickedDice.rotation.y;
    const duration = (remaining / (Math.PI / 2));
    
    // Tween the dice's rotation to the updated target.
    clickedDice.userData.rotationTween = gsap.to(clickedDice.rotation, {
      duration: duration,
      y: clickedDice.userData.targetRotation,
      ease: "power2.out",
      onUpdate: function() {
        updateAddToCartButtonPosition(clickedDice);
      },
      onComplete: function() {
        updateAddToCartButtonPosition(clickedDice);
        clickedDice.userData.rotationTween = null;
      }
    });
  }
});

// Position the Add to Cart button on the front face of the dice.
// Uses the local point (0, 0, diceSize/2) and projects it to screen coordinates.
function updateAddToCartButtonPosition(dice) {
  const diceSize = 9;
  const halfSize = diceSize / 2;
  const localPoint = new THREE.Vector3(0, 0, halfSize);
  const worldPoint = dice.localToWorld(localPoint.clone());
  const vector = worldPoint.clone();
  vector.project(camera);
  const width = container.clientWidth;
  const height = container.clientHeight;
  const x = (vector.x + 1) / 2 * width;
  const y = (-vector.y + 1) / 2 * height;
  
  const button = document.getElementById('addToCartButton');
  button.style.left = (x - 50) + 'px';
  button.style.top = (y - 20) + 'px';
  button.dataset.product = dice.userData.product;
  button.style.display = 'block';
}

document.getElementById('addToCartButton').addEventListener('click', function(event) {
  event.stopPropagation();
  const product = this.dataset.product;
  alert(`Added ${product} to cart!`);
  this.style.display = 'none';
});

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
</script>